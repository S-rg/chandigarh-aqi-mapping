#!/usr/bin/env python3
# generate_config_header.py
# Usage:
# - as PlatformIO extra script: platformio will call this file (it will find Import("env"))
# - or run standalone: python3 scripts/generate_config_header.py

try:
    # PlatformIO exposes Import("env")
    from SCons.Script import Import  # type: ignore
    Import("env")
    PLATFORMIO = True
except Exception:
    PLATFORMIO = False

import yaml, os, re, sys
from collections import OrderedDict

CONFIG_FILE = "config/sensors.yaml"
OUTPUT_FILE = "include/SensorsConfig.h"

def comms_name_to_key_map(name):
    if name == "COMM_HARDWARE_SERIAL":
        return 0
    elif name == "COMM_SOFTWARE_SERIAL":
        return 1
    elif name == "COMM_I2C":
        return 2
    elif name == "COMM_UNKNOWN":
        return 3
    else:
        return 3

# helpers
def sanitize_ident(s: str) -> str:
    # produce an identifier safe for macros: uppercase, letters/digits/_ only
    s = re.sub(r"[^0-9a-zA-Z_]", "_", s)
    s = re.sub(r"_+", "_", s)
    s = s.strip("_")
    return s.upper() if s else "X"

def cstr(s: str) -> str:
    # escape C string
    if s is None:
        return '""'
    return '"' + s.replace("\\", "\\\\").replace('"', '\\"') + '"'

def ensure_list(x):
    if x is None:
        return []
    if isinstance(x, list):
        return x
    if isinstance(x, dict):
        # If the dict has integer keys, treat as list-like (YAML map-as-list)
        if all(isinstance(k, (int, str)) and str(k).isdigit() for k in x.keys()):
            return [x[k] for k in sorted(x.keys(), key=lambda k: int(k))]
        # If the dict has repeated keys in YAML, only the last one is kept (YAML limitation)
        # To support multiple measurements, check for flat dict with repeated measurement keys
        # If keys are repeated (e.g. measurement_id, name, unit), group them into dicts
        keys = list(x.keys())
        if keys.count('measurement_id') > 1 or keys.count('name') > 1 or keys.count('unit') > 1:
            # Unlikely, but if so, try to group
            items = list(x.items())
            result = []
            temp = {}
            for k, v in items:
                temp[k] = v
                if k == 'unit':
                    result.append(temp)
                    temp = {}
            if temp:
                result.append(temp)
            return result
        # Otherwise, treat as a single measurement dict
        return [x]
    return [x]

def read_yaml(path):
    if not os.path.exists(path):
        print(f"[WARN] config file {path} not found.")
        return {}
    with open(path, "r") as f:
        return yaml.safe_load(f)

def generate_header(data, out_path):
    debug = bool(data.get("DEBUG", False))
    sensors = data.get("Sensors", OrderedDict())
    # normalize sensors: keep order
    if not isinstance(sensors, dict):
        raise RuntimeError("Sensors must be a mapping in YAML")

    # gather comm types
    comm_set = OrderedDict()
    for key, s in sensors.items():
        comms = s.get("comms", "UNKNOWN")
        comm_set[comms] = True

    # header begin
    with open(out_path, "w") as out:
        def w(line=""):
            out.write(line + "\n")

        guard = sanitize_ident(os.path.basename(out_path)).upper() + "_H"
        w("// Auto-generated by generate_config_header.py. DO NOT EDIT.")
        w(f"#ifndef {guard}")
        w(f"#define {guard}")
        w("")
        w("#include <stdint.h>")
        w('#include "DataTypes.h"')
        w("")
        w(f"#define SENSORS_DEBUG {1 if debug else 0}")
        w("")
        # Measurement info
        w("typedef struct {")
        w("  uint8_t measurement_id;")
        w("  const char* name;")
        w("  const char* unit;")
        w("} MeasurementInfo;")
        w("")
        # Sensor info
        w("typedef struct {")
        w("  uint16_t sensor_id;          // user-defined id")
        w("  const char* config_key;      // YAML key for this sensor")
        w("  const char* part_name;       // human part name (e.g. Plantower PMS7003)")
        w("  const char* type;            // sensor 'type' used by factory")
        w("  CommsType comms;")
        w("  int32_t port_no;             // port number (I2C bus index / UART index) or -1")
        w("  uint16_t i2c_address;        // i2c address of sensor or -1")
        w("  int16_t rx_pin;              // optional, -1 if unused")
        w("  int16_t tx_pin;              // optional, -1 if unused")
        w("  int32_t baud_rate;           // optional, -1 if unused")
        w("  const MeasurementInfo* measurements;")
        w("  uint8_t measurement_count;")
        w("} SensorInfo;")
        w("")
        # generate measurement arrays
        w("// Measurement arrays")
        for key, s in sensors.items():
            meas_list = ensure_list(s.get("measurements", []))
            arr_name = sanitize_ident(f"{key}_MEASUREMENTS")
            w(f"static const MeasurementInfo {arr_name}[] = {{")
            for m in meas_list:
                # m expected to be mapping with measurement_id,name,unit
                if not isinstance(m, dict):
                    continue
                mid = m.get("measurement_id", 0)
                mname = m.get("name", "")
                munit = m.get("unit", "")
                w(f"  {{ (uint8_t){mid}, {cstr(str(mname))}, {cstr(str(munit))} }},")
            w("};")
            w("")

        # sensor array
        w("// Sensor table")
        w("static const SensorInfo sensors_config[] = {")
        for key, s in sensors.items():
            sid = s.get("id", 0)
            part = s.get("part_name", s.get("name", key))
            stype = s.get("type", "")
            comms = s.get("comms", "UNKNOWN")
            port_no = s.get("port_no", -1)
            i2c_address = s.get("i2c_address", -1)
            rx_pin = s.get("rx_pin", s.get("rx_pin", -1))
            tx_pin = s.get("tx_pin", s.get("tx_pin", -1))
            baud_rate = s.get("baud_rate", s.get("baud_rate", -1))
            arr_name = sanitize_ident(f"{key}_MEASUREMENTS")
            meas_list = ensure_list(s.get("measurements", []))
            count = len(meas_list)
            w(f"  {{ (uint16_t){sid}, {cstr(key)}, {cstr(part)}, {cstr(stype)}, COMM_{comms}, (int32_t){port_no}, (uint16_t){i2c_address}, (int16_t){rx_pin}, (int16_t){tx_pin}, (int32_t){baud_rate}, {arr_name}, (uint8_t){count} }},")
        w("};")
        w("")
        w(f"#define SENSOR_COUNT {(len(sensors))}")
        w("")

        # macros for sensor ids and measurement constants
        w("// Convenience macros for sensor IDs and measurement IDs")
        for key, s in sensors.items():
            sid = s.get("id", 0)
            sensor_macro = sanitize_ident(f"SENSOR_ID_{key}")
            w(f"#define {sensor_macro} {sid}")
            # per-measurement macros
            meas_list = ensure_list(s.get("measurements", []))
            for m in meas_list:
                mid = m.get("measurement_id", 0)
                name = m.get("name", "")
                mmacro = sanitize_ident(f"MEAS_{key}_{name}")
                w(f"#define {mmacro} {mid}")
            w("")
        # debug-friendly string arrays (only compiled but always present; user can rely on SENSORS_DEBUG)
        w("// Debug helpers: arrays of names (useful when SENSORS_DEBUG == 1)")
        w("static const char* const sensor_config_key[] = {")
        for key in sensors.keys():
            w(f"  {cstr(key)},")
        w("};")
        w("")
        w("static const char* const sensor_part_name[] = {")
        for key, s in sensors.items():
            part = s.get("part_name", s.get("name", ""))
            w(f"  {cstr(part)},")
        w("};")
        w("")
        # measurement names flattened, optional helper: index by (sensor index, meas index)
        w("// For debug: measurement names by sensor (array of arrays).")
        w("static const MeasurementInfo* const sensor_measurements[] = {")
        for key in sensors.keys():
            arr_name = sanitize_ident(f"{key}_MEASUREMENTS")
            w(f"  {arr_name},")
        w("};")
        w("")
        # note on factory
        w("/*")
        w("  Factory note:")
        w("  - You must provide factory functions that create your sensor objects (polymorphic).")
        w("  - For example, for type \"PMSensor\" you could implement:")
        w("      #ifdef __cplusplus")
        w("      class SensorBase; // forward")
        w("      extern SensorBase* createPMSensor(const SensorInfo* cfg);")
        w("      #endif")
        w("  - Then at startup you can iterate sensors_config[] and call the correct factory")
        w("    based on sensors_config[i].type (string) or create a compile-time mapping.")
        w("*/")
        w("")
        w(f"#endif // {guard}")
    print(f"[INFO] Wrote {out_path}")

def main():
    data = read_yaml(CONFIG_FILE)
    if not data:
        # still generate minimal header
        print("[WARN] No data read from YAML; generating empty header.")
        data = {"DEBUG": False, "Sensors": {}}
    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    generate_header(data, OUTPUT_FILE)

if __name__ == "__main__":
    main()

# If PlatformIO ran this as extra script, call main immediately.
if PLATFORMIO:
    main()
